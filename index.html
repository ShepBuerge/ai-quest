<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AI Quest ‚Äî Learn AI the Fun Way</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0a0a0f">
  <style>
    html, body { margin:0; height:100%; background:#0a0a0f; }
    canvas { display:block; width:100vw; height:100vh; background: #0a0a0f; }
    /* All UI is drawn to canvas; no DOM controls are used. */
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
/* ===== Original app code (unchanged except for manifest link & theme-color) ===== */
const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
const rand = (a,b)=>a+Math.random()*(b-a);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const now = ()=>performance.now();
const Storage = { get(key, fallback) { try { return JSON.parse(localStorage.getItem(key)) ?? fallback; } catch { return fallback; } }, set(key, val) { localStorage.setItem(key, JSON.stringify(val)); } };
const Theme = { bg: "#0a0a0f", panel: "#121225", neon: "#00ffcc", neon2:"#ff2fb3", text: "#e8f1ff", faint:"#8aa0b8", good:"#35ff8a", warn:"#ffd166", bad:"#ff6b6b", shadow:"rgba(0,0,0,0.25)" };
const Topics = [ { id: "llms_basics", title: "LLMs & Transformers", colors: ["#00ffcc","#2e87ff"], lessons: { bite: ["Transformers are the backbone of modern LLMs. They replace recurrence with attention so models can weigh which parts of text matter most‚Äîenabling parallel training and strong performance. (Source: 'Attention Is All You Need')"], regular: ["Transformers use self-attention to compute relationships across tokens in parallel. Positional encodings tell the model 'where' words sit. This design trains faster than RNNs and scales well. (Vaswani et al.)","Pretraining reads huge corpora with a next-token objective; then we adapt with methods like instruction fine-tuning and RLHF to better follow user intent. (Ouyang et al.)","Despite prowess, LLMs can hallucinate. Pairing with retrieval or uncertainty cues improves reliability. (See research notes in Sources panel.)"], deep: ["Architecture: Multi-head self-attention, residual connections, layer norm, and feed-forward sublayers. Attention weights surface syntactic and semantic patterns, often specializing by head (e.g., coreference). (Vaswani et al.)","Alignment: Instruction fine-tuning provides exemplars; RLHF learns a reward model from human rankings, then optimizes a policy with PPO, improving helpfulness and tone. (Ouyang et al.)","Limits & mitigations: distribution shift, hallucinations, and calibration. Add retrieval, chain-of-thought evaluation, and UX surfacing of uncertainty to support trustworthy decisions."] }, sources: [ {label:"Vaswani et al. 2017", ref:"turn1search62"}, {label:"Ouyang et al. 2022", ref:"turn1search83"} ], flashcards: [ {q:"Why did Transformers replace RNNs/CNNs for many NLP tasks?", a:"Parallelizable self-attention captures global dependencies efficiently, improving quality and training speed. (Vaswani et al.)", refs:["turn1search62"]}, {q:"What is RLHF in one line?", a:"Fine-tune with a learned reward model built from human preference rankings to better follow instructions. (Ouyang et al.)", refs:["turn1search83"]} ], quiz: [ {q:"Self-attention lets a token attend to:", choices:["Only previous token","All tokens in the sequence","Only next token","Random subset"], correct:1}, {q:"RLHF primarily uses:", choices:["Gradient-free search","Human demonstrations only","Human preference rankings + RL","Manual rule programming"], correct:2} ], videoNote:"This module‚Äôs video uses a narrated animation drawn to the canvas (placeholder)." }, { id: "ai_daily_life", title: "AI in Daily Life (Home & Work)", colors: ["#ff2fb3","#ffd166"], lessons: { bite: ["At home: AI powers recommendations, voice assistants, and smart devices; at work: drafting, analyzing, and summarizing help you do more with less. Use it as a collaborator‚Äînot a final source of truth."], regular: ["Use cases at work: summarize meetings, draft emails, structure research, build outlines, visualize data narratives. Safeguard sensitive data and verify outputs.","Use cases at home: meal planning, workouts, travel planning, hobby coaching. Treat outputs as drafts; double-check logistics and safety-critical info.","Build a habit: short daily reps + weekly review. Streaks and small wins compound quickly."], deep: ["Workflow design: Write task briefs for the model (goal, audience, constraints, examples). Iterate via retrieval practice‚Äîclose the app and recall the steps; then re-open and compare.","Reliability: Add citations, request uncertainty cues, and keep a checklist for facts to verify. Build a personal library of trusted sources.","Ethics & IP: Avoid copying; transform ideas into your own words. Attribute sources; respect licenses."] }, sources: [ {label:"Duolingo streak research blogs", ref:"turn1search79"}, {label:"Duolingo A/B tests on streak/engagement", ref:"turn1search80"} ], flashcards: [ {q:"Two safe defaults for AI at work?", a:"No sensitive data; verify critical facts with primary sources.", refs:[]}, {q:"What habit mechanic increases return rate?", a:"Streak + timely reminders and visual milestone animations. (Duolingo blog)", refs:["turn1search79","turn1search80"]} ], quiz: [ {q:"Best first step for an AI-assisted task?", choices:["Ask for an answer immediately","Write a clear task brief with audience/constraints","Paste private data to add context","Skip verification"], correct:1} ], videoNote:"Canvas-drawn storyboard on habit loops and daily reps." }, { id:"memory", title:"Make It Stick: Memory Tricks", colors:["#35ff8a","#2e87ff"], lessons:{ bite:["Two big levers: spaced repetition (review later, not sooner) and retrieval practice (test yourself, don‚Äôt just re-read)."], regular:["Spacing: Review after a growing delay; optimal gap scales with your target test date. (Cepeda et al.)","Retrieval: Recalling from memory beats re-studying for long-term retention. (Karpicke & Roediger)","Interleave topics and use dual coding (words + visuals) to deepen encoding."], deep:["Implement SRS with per-card EF and interval scheduling; mix retrieval, explanation, and teach-back prompts.","Design quizzing for desirable difficulty: near the edge of forgetting; provide immediate, supportive feedback.","Reflect: note confusions and craft targeted micro-drills for the next session."] }, sources:[ {label:"Cepeda et al. spacing over months", ref:"turn1search58"}, {label:"Karpicke & Roediger retrieval practice", ref:"turn1search59"} ], flashcards:[ {q:"Why space practice?", a:"It strengthens long-term retention by revisiting as forgetting starts. (Cepeda et al.)", refs:["turn1search58"]}, {q:"What beats re-reading?", a:"Repeated retrieval (self-testing). (Karpicke & Roediger)", refs:["turn1search59"]} ], quiz:[ {q:"Spacing works best when reviews are:", choices:["Back-to-back","At expanding intervals","Random only","Once per month"], correct:1} ], videoNote:"Canvas-based infographic of spacing vs. cramming." }];
let profile = Object.assign({}, { name: "Player", xp:0, level:1, streak:0, lastStudyUTC:0, coins:0, boosts:0, badges:[], srs:{}, prefs:{ lessonLength:"regular", sound:true, theme:"neon" }, feedback:[] }, JSON.parse(localStorage.getItem("aiq_profile")||"{}"));
function saveProfile(){ localStorage.setItem("aiq_profile", JSON.stringify(profile)); }
function addXP(amount) { profile.xp += amount; const newLevel = Math.floor(1 + Math.sqrt(profile.xp/150)); if (newLevel > profile.level) { profile.level = newLevel; showToast(`Level Up! You reached Level ${newLevel} üéâ`, "#35ff8a"); if(!profile.badges.includes("level5") && newLevel>=5){ profile.badges.push("level5"); showToast(`Badge earned: Level 5 Achieved üèÖ`, "#ff2fb3"); } if(!profile.badges.includes("level10") && newLevel>=10){ profile.badges.push("level10"); showToast(`Badge earned: Level 10 Achieved üèÖ`, "#ff2fb3"); } } saveProfile(); }
function updateStreak() { const daysSince = (Date.now() - (profile.lastStudyUTC||0)) / (1000*60*60*24); if (daysSince < 36/24) {} else if (daysSince < 60/24) { profile.streak += 1; } else if (daysSince < 48/24) { profile.streak = Math.max(1, profile.streak + 1); } else { profile.streak = 1; } profile.lastStudyUTC = Date.now(); saveProfile(); }
async function requestNotifs(){ if(!("Notification" in window)) return showToast("Notifications not supported", "#ffd166"); const perm = await Notification.requestPermission(); if(perm==="granted"){ showToast("Daily reminder enabled. You‚Äôll get a nudge around 6pm.", "#00ffcc"); scheduleLocalReminder(); } }
function scheduleLocalReminder(){ const msUntil6pm = (()=> { const d = new Date(); d.setHours(18,0,0,0); let t = d.getTime() - Date.now(); if (t<0) t += 24*3600*1000; return t; })(); setTimeout(()=>{ if(Notification.permission==="granted"){ new Notification("Keep your AI Quest streak!", { body:"Do a 2‚Äì3 min bite-sized lesson now. üî•" }); } }, msUntil6pm); }
function getCardKey(topicId, idx){ return `${topicId}#${idx}`; }
function ensureCardState(key){ profile.srs[key] ??= { interval:1, ef:2.5, reps:0, lapses:0, due: Date.now() }; return profile.srs[key]; }
function srsReview(cardKey, quality){ const s = ensureCardState(cardKey); if (quality < 3) { s.reps = 0; s.interval = 1; s.lapses += 1; } else { s.reps += 1; if (s.reps === 1) s.interval = 1; else if (s.reps === 2) s.interval = 3; else s.interval = Math.round(s.interval * s.ef); s.ef = Math.max(1.3, s.ef + (0.1 - (5-quality)*(0.08 + (5-quality)*0.02))); } s.due = Date.now() + s.interval * 24*3600*1000; profile.srs[cardKey] = s; saveProfile(); }
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let W=0,H=0, lastT=0, mouse={x:0,y:0,down:false};
let toasts=[];
function resize(){ const w = window.innerWidth, h = window.innerHeight; canvas.width = Math.round(w * DPR); canvas.height = Math.round(h * DPR); canvas.style.width = w + "px"; canvas.style.height = h + "px"; ctx.setTransform(DPR,0,0,DPR,0,0); W=w; H=h; }
window.addEventListener('resize', resize);
function showToast(text, color){ toasts.push({text, color: color||"#00ffcc", t: performance.now(), ttl: 3000}); }
canvas.addEventListener('mousemove', e=> { const r = canvas.getBoundingClientRect(); mouse.x = e.clientX - r.left; mouse.y = e.clientY - r.top; });
canvas.addEventListener('mousedown', ()=> mouse.down=true);
canvas.addEventListener('mouseup', ()=> mouse.down=false);
window.addEventListener('keydown', onKey);
function drawText(txt, x,y, size=18, color="#e8f1ff", align="left", maxW=null){ ctx.fillStyle = color; ctx.font = `600 ${size}px ui-sans-serif,system-ui,Segoe UI,Roboto`; ctx.textAlign = align; ctx.textBaseline = "top"; if(maxW){ wrapText(txt,x,y,size*1.35,maxW); } else ctx.fillText(txt,x,y); }
function wrapText(txt,x,y,lh,maxW){ const words=txt.split(" "); let line="", th=y; for(let n=0;n<words.length;n++){ const test = line + words[n] + " "; if(ctx.measureText(test).width > maxW && n>0){ ctx.fillText(line,x,th); line=words[n]+" "; th+=lh; } else line=test; } ctx.fillText(line,x,th); }
function button(label, x,y,w,h, color="#121225"){ const hover = mouse.x> x && mouse.x< x+w && mouse.y> y && mouse.y< y+h; ctx.fillStyle = hover ? "#1b1b39" : color; roundRect(x,y,w,h,12); ctx.fill(); ctx.strokeStyle = "#00ffcc"; ctx.lineWidth = 2; ctx.stroke(); drawText(label, x+w/2, y+h/2-10, 18, "#e8f1ff", "center"); if(hover && mouse.down){ mouse.down=false; return true; } return false; }
function pill(text,x,y){ ctx.fillStyle = "#141430"; roundRect(x,y, ctx.measureText(text).width+24, 28, 14); ctx.fill(); drawText(text, x+12,y+6,16,"#8aa0b8","left"); }
function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
let scene = "home"; let currentTopic = null; let currentLessonTier = profile.prefs.lessonLength; let flashIndex = 0; let quizIndex = 0; let typing = {active:false,text:""}; let quizScore=0; let starRating = 0;
function onKey(e){ if(scene==="feedback"){ if(!typing.active) typing.active = true; if(e.key==="Backspace") typing.text = typing.text.slice(0,-1); else if(e.key==="Enter"){ submitFeedback(); } else if(e.key.length===1) typing.text += e.key; } if(scene==="home"){ if(e.key.toLowerCase()==="n") requestNotifs(); } }
function drawBackground(){ ctx.clearRect(0,0,W,H); const t = performance.now()/1000; ctx.fillStyle = "#0a0a0f"; ctx.fillRect(0,0,W,H); ctx.save(); ctx.globalAlpha = 0.25; for(let i=-100;i<W+100;i+=40){ ctx.strokeStyle = i%80===0? "#00ffcc" : "#112"; ctx.beginPath(); ctx.moveTo(i + Math.sin(t+i)*2,0); ctx.lineTo(i,H); ctx.stroke(); } for(let j=-100;j<H+100;j+=40){ ctx.strokeStyle = j%80===0? "#ff2fb3" : "#112"; ctx.beginPath(); ctx.moveTo(0,j + Math.cos(t+j)*2); ctx.lineTo(W,j); ctx.stroke(); } ctx.restore(); }
function drawHeader(title){ drawText("AI Quest", 24, 16, 28, "#00ffcc"); pill(`Level ${profile.level} ‚Ä¢ ${profile.xp} XP`, 150, 18); pill(`üî• Streak: ${profile.streak}`, 300, 18); pill(`Boosts: ${profile.boosts}`, 460, 18); drawText(title, W-24, 16, 24, "#e8f1ff", "right"); }
function drawToasts(){ const t=performance.now(); toasts = toasts.filter(s=> t-s.t < s.ttl); let y = H-100; toasts.forEach(s=>{ ctx.globalAlpha = 0.9; ctx.fillStyle = s.color; roundRect(20,y, W-40, 50, 10); ctx.fill(); drawText(s.text, 36, y+12, 18, "#001018"); y -= 60; }); ctx.globalAlpha = 1; }
function sceneHome(){ drawHeader("Home"); const msg = "Choose a topic and a lesson length. Press N to enable reminders."; drawText(msg, 24, 64, 18, "#8aa0b8", "left", W-48); const tiers = ["bite","regular","deep"]; tiers.forEach((t,i)=>{ const x = 24 + i*(140+16), y = 120; const label = t==="bite"?"Bite (2‚Äì3m)":t==="regular"?"Regular (5‚Äì10m)":"Deep (15m+)"; const clicked = button((currentLessonTier===t?"‚úì ":"")+label, x, y, 140, 52); if(clicked){ currentLessonTier = t; profile.prefs.lessonLength = t; saveProfile(); } }); let y = 200, x = 24, ww = W-48, cardH = 120; Topics.forEach(topic=>{ ctx.fillStyle = "#121225"; roundRect(x,y, ww, cardH, 16); ctx.fill(); const g = ctx.createLinearGradient(x,y,x+ww,y); g.addColorStop(0, topic.colors[0]); g.addColorStop(1, topic.colors[1]); ctx.fillStyle = g; roundRect(x,y, 8, cardH, 16); ctx.fill(); drawText(topic.title, x+24, y+16, 22, "#e8f1ff"); drawText("Learn ‚Ä¢ Flashcards ‚Ä¢ Quiz ‚Ä¢ Video", x+24, y+48, 16, "#8aa0b8"); const learn = button("Learn", x+ww-420, y+32, 100, 56); const flash = button("Flashcards", x+ww-310, y+32, 120, 56); const quiz  = button("Quiz", x+ww-180, y+32, 70, 56); const video = button("Video", x+ww-100, y+32, 70, 56); if(learn){ currentTopic=topic; scene="learn"; } if(flash){ currentTopic=topic; flashIndex=0; scene="flash"; } if(quiz ){ currentTopic=topic; quizIndex=0; scene="quiz"; } if(video){ currentTopic=topic; scene="video"; } y += cardH + 16; }); if(button("View Progress", 24, H-72, 160, 48)) scene="progress"; if(button("Give Feedback", 196, H-72, 160, 48)) scene="feedback"; if(button("Sources & Copyright", 368, H-72, 220, 48)) scene="sources"; }
function sceneLearn(){ const t = currentTopic; drawHeader(`Learn ‚Ä¢ ${t.title}`); const arr = t.lessons[currentLessonTier] || []; const boxY = 72, boxH = H-160; ctx.fillStyle = "#121225"; roundRect(24,boxY, W-48, boxH, 16); ctx.fill(); ctx.save(); ctx.beginPath(); roundRect(24,boxY, W-48, boxH, 16); ctx.clip(); let y = boxY + 20; arr.forEach((para,i)=>{ drawText(`‚Ä¢ ${para}`, 40, y, 18, "#e8f1ff", "left", W-80); y += 80; }); ctx.restore(); const xpEarn = currentLessonTier==="bite"?15: currentLessonTier==="regular"?35:70; if(button(`Complete (+${xpEarn} XP)`, W-250, H-72, 220, 48, "#121225")){ addXP(xpEarn); updateStreak(); if(!profile.badges.includes("first-lesson")){ profile.badges.push("first-lesson"); showToast("Badge earned: First Lesson üèÖ", "#ff2fb3"); } showToast("Great job! Want to quiz yourself for better retention?", "#00ffcc"); } if(button("Back", 24, H-72, 100, 48)) scene="home"; }
function sceneFlash(){ const t=currentTopic, cards=t.flashcards; drawHeader(`Flashcards ‚Ä¢ ${t.title}`); if(cards.length===0){ drawText("No cards yet.", 24, 72); if(button("Back",24,H-72,100,48)) scene="home"; return; } const card = cards[flashIndex]; const cardKey = getCardKey(t.id, flashIndex); ctx.fillStyle = "#121225"; roundRect(W/2-300, H/2-160, 600, 280, 16); ctx.fill(); drawText("Q:", W/2-260, H/2-140, 18, "#00ffcc"); drawText(card.q, W/2-260, H/2-110, 20, "#e8f1ff", "left", 520); if(button("Show Answer", W/2-120, H/2+40, 240, 50)){ ctx.fillStyle = "rgba(0,0,0,0.75)"; roundRect(W/2-300, H/2-160, 600, 280,16); ctx.fill(); drawText("A:", W/2-260, H/2-140, 18, "#00ffcc"); drawText(card.a, W/2-260, H/2-110, 20, "#e8f1ff", "left", 520); if(button("Again", W/2-280, H/2+80, 120, 44)){ srsReview(cardKey,1); addXP(3); } if(button("Good",  W/2-60,  H/2+80, 120, 44)){ srsReview(cardKey,4); addXP(6); } if(button("Easy",  W/2+160, H/2+80, 120, 44)){ srsReview(cardKey,5); addXP(8); } }
  if(button("Prev", 24, H-72, 100, 48)) flashIndex = (flashIndex-1+cards.length)%cards.length;
  if(button("Next", 132, H-72, 100, 48)) flashIndex = (flashIndex+1)%cards.length;
  if(button("Back", W-124, H-72, 100, 48)) scene="home";
}
function sceneQuiz(){ const t=currentTopic; drawHeader(`Quiz ‚Ä¢ ${t.title}`); const items = t.quiz; if(quizIndex===0) quizScore=0; if(quizIndex>=items.length){ ctx.fillStyle = "#121225"; roundRect(W/2-280, H/2-120, 560, 220,16); ctx.fill(); drawText(`Score: ${quizScore}/${items.length}`, W/2, H/2-90, 26, "#00ffcc", "center"); let msg="Nice! If something felt shaky, you can do a quick review‚Äîor skip and keep going. Your call!"; drawText(msg, W/2-240, H/2-54, 18, "#e8f1ff", "left", 480); if(button("Claim Rewards", W/2-120, H/2+10, 240, 50)){ addXP(20+10*quizScore); if(!profile.badges.includes("quizzer")){ profile.badges.push("quizzer"); } scene="home"; } if(button("Review weak spots", W/2-140, H/2+70, 280, 44)){ scene="flash"; } return; }
  const q=items[quizIndex];
  ctx.fillStyle = "#121225"; roundRect(24, 72, W-48, 240,16); ctx.fill();
  drawText(q.q, 40, 92, 22, "#e8f1ff", "left", W-80);
  const cols=2, bw=(W-80)/cols, bh=64;
  q.choices.forEach((c,i)=>{
    const col = i%cols, row = Math.floor(i/cols);
    const x=40+col*(bw+0), y=160+row*(bh+12);
    const ok = button(c,x,y,bw-12,bh);
    if(ok){ if(i===q.correct){ quizScore++; showToast("Correct! ‚úî", "#35ff8a"); } else showToast("Good try! ‚ú®", "#ffd166"); quizIndex++; }
  });
  if(button("Back", 24, H-72, 100, 48)) scene="home";
}
function sceneVideo(){ drawHeader(`Video ‚Ä¢ ${currentTopic.title}`); ctx.fillStyle = "#121225"; roundRect(24,72,W-48,H-160,16); ctx.fill(); drawText("Short animated explainer (placeholder). The final version will render narration text, key frames, and highlights directly to canvas.", 40, 92, 20, "#e8f1ff", "left", W-80); if(button("Mark Watched (+10 XP)", W-260, H-72, 240, 48)){ addXP(10); scene="home"; } if(button("Back", 24, H-72, 100, 48)) scene="home"; }
function sceneProgress(){ drawHeader("Progress"); ctx.fillStyle = "#121225"; roundRect(24,72,W-48,H-160,16); ctx.fill(); drawText(`XP: ${profile.xp}  ‚Ä¢ Level: ${profile.level}  ‚Ä¢ Streak: ${profile.streak}`, 40, 92, 20, "#e8f1ff"); drawText(`Badges: ${profile.badges.join(", ")||"‚Äî"}`, 40, 120, 18, "#8aa0b8"); drawText("Upcoming flashcards (due soon):", 40, 160, 18, "#00ffcc"); const due = Object.entries(profile.srs).filter(([,s])=> s.due <= Date.now()+48*3600*1000).slice(0,6); let y=186; due.forEach(([k,s])=>{ drawText(`${k} in ${ ( (s.due-Date.now())/(3600*1000) ).toFixed(1)} hrs`, 60,y,16,"#e8f1ff"); y+=22; }); if(button("Back", 24, H-72, 100, 48)) scene="home"; }
function sceneFeedback(){ drawHeader("Feedback"); ctx.fillStyle = "#121225"; roundRect(24,72,W-48,H-160,16); ctx.fill(); drawText("Tell us what to improve (content, UI, or topics). Your feedback helps steer the roadmap.", 40, 92, 18, "#e8f1ff", "left", W-80); drawText("Rating:", 40, 130, 18, "#00ffcc"); for(let i=1;i<=5;i++){ const x=110+i*36, y=128, r=12; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle = i<=starRating? "#ff2fb3":"#30304a"; ctx.fill(); if(Math.hypot(mouse.x-x, mouse.y-y)<r && mouse.down){ mouse.down=false; starRating=i; } } drawText("Your comment (type, Enter to submit):", 40, 170, 16, "#8aa0b8"); ctx.fillStyle="#0e0e22"; roundRect(40,200,W-80,140,10); ctx.fill(); ctx.strokeStyle="#2a2a60"; ctx.stroke(); drawText(typing.text || "Start typing...", 52, 212, 18, typing.text?"#e8f1ff":"#546", "left", W-110); if(button("Submit", W-140, 350, 100, 44)){ submitFeedback(); } if(button("Back", 24, H-72, 100, 48)) scene="home"; }
function submitFeedback(){ profile.feedback.push({ t:Date.now(), stars:starRating||0, text:typing.text||"" }); saveProfile(); starRating=0; typing.text=""; typing.active=false; showToast("Thanks! Feedback recorded.", "#00ffcc"); scene="home"; }
function sceneSources(){ drawHeader("Sources & Copyright"); ctx.fillStyle = "#121225"; roundRect(24,72,W-48,H-160,16); ctx.fill(); const lines = [ "- We summarize in our own words and cite originals. Avoid copying; attribute ideas and figures.", "- US Fair Use (17 U.S.C. ¬ß107) and DMCA ¬ß512 safe-harbor guide platform responsibilities.", "- If you plan to monetize or publish widely, verify each source/license; ask before posting if unsure.", "- Organization note: Using company time, data, or branding? Follow internal AI and Acceptable Use policies." ]; let y=92; lines.forEach(l=>{ drawText(l,40,y,18,"#e8f1ff","left",W-80); y+=36; }); drawText("External references:", 40, y, 18, "#00ffcc"); y+=28; [ "Vaswani et al., Attention Is All You Need (arXiv)", "Ouyang et al., Training LMs to Follow Instructions with Human Feedback (arXiv)", "Cepeda et al., Spacing Effects (Psych Sci)", "Karpicke & Roediger, Retrieval Practice (JML)", "Duolingo Streak habit research blog", "Duolingo streak A/B tests blog", "17 U.S.C. ¬ß107 Fair Use (LII)", "17 U.S.C. ¬ß512 DMCA Safe Harbor (LII)" ].forEach(ref=>{ drawText("‚Ä¢ "+ref, 40, y, 16, "#8aa0b8", "left", W-80); y+=24; }); if(button("Back", 24, H-72, 100, 48)) scene="home"; }
function tick(ts){ const dt = ts - lastT; lastT = ts; resize(); drawBackground(); if(scene==="home") sceneHome(); if(scene==="learn") sceneLearn(); if(scene==="flash") sceneFlash(); if(scene==="quiz") sceneQuiz(); if(scene==="video") sceneVideo(); if(scene==="progress") sceneProgress(); if(scene==="feedback") sceneFeedback(); if(scene==="sources") sceneSources(); drawToasts(); requestAnimationFrame(tick); }
resize(); requestAnimationFrame(tick);
if('serviceWorker' in navigator){ navigator.serviceWorker.register('sw.js'); }
</script>
</body>
</html>
